import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import { timestamp, files, shell, routes } from '../__sapper__/service-worker.js';
var ASSETS = "cache".concat(timestamp); // `shell` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static` directory

var to_cache = shell.concat(files);
var cached = new Set(to_cache);
self.addEventListener('install', function (event) {
  event.waitUntil(caches.open(ASSETS).then(function (cache) {
    return cache.addAll(to_cache);
  }).then(function () {
    self.skipWaiting();
  }));
});
self.addEventListener('activate', function (event) {
  event.waitUntil(caches.keys().then(
  /*#__PURE__*/
  function () {
    var _ref = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee(keys) {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // delete old caches
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context.prev = 3;
              _iterator = keys[Symbol.iterator]();

            case 5:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context.next = 13;
                break;
              }

              key = _step.value;

              if (!(key !== ASSETS)) {
                _context.next = 10;
                break;
              }

              _context.next = 10;
              return caches.delete(key);

            case 10:
              _iteratorNormalCompletion = true;
              _context.next = 5;
              break;

            case 13:
              _context.next = 19;
              break;

            case 15:
              _context.prev = 15;
              _context.t0 = _context["catch"](3);
              _didIteratorError = true;
              _iteratorError = _context.t0;

            case 19:
              _context.prev = 19;
              _context.prev = 20;

              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }

            case 22:
              _context.prev = 22;

              if (!_didIteratorError) {
                _context.next = 25;
                break;
              }

              throw _iteratorError;

            case 25:
              return _context.finish(22);

            case 26:
              return _context.finish(19);

            case 27:
              self.clients.claim();

            case 28:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 15, 19, 27], [20,, 22, 26]]);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }()));
});
self.addEventListener('fetch', function (event) {
  if (event.request.method !== 'GET' || event.request.headers.has('range')) {
    return;
  }

  var url = new URL(event.request.url); // don't try to handle e.g. data: URIs

  if (!url.protocol.startsWith('http')) {
    return;
  } // ignore dev server requests


  if (url.hostname === self.location.hostname && url.port !== self.location.port) {
    return;
  } // always serve static files and bundler-generated assets from cache


  if (url.host === self.location.host && cached.has(url.pathname)) {
    event.respondWith(caches.match(event.request));
    return;
  } // for pages, you might want to serve a shell `index.html` file,
  // which Sapper has generated for you. It's not right for every
  // app, but if it's right for yours then uncomment this section
  // if (url.origin === self.origin && routes.find(route => route.pattern.test(url.pathname))) {
  // event.respondWith(caches.match('/index.html'));
  // return;
  // }


  if (event.request.cache === 'only-if-cached') {
    return;
  } // for everything else, try the network first, falling back to
  // cache if the user is offline. (If the pages never change, you
  // might prefer a cache-first approach to a network-first one.)


  event.respondWith(caches.open("offline".concat(timestamp)).then(
  /*#__PURE__*/
  function () {
    var _ref2 = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee2(cache) {
      var response, _response;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return fetch(event.request);

            case 3:
              response = _context2.sent;
              cache.put(event.request, response.clone());
              return _context2.abrupt("return", response);

            case 8:
              _context2.prev = 8;
              _context2.t0 = _context2["catch"](0);
              _context2.next = 12;
              return cache.match(event.request);

            case 12:
              _response = _context2.sent;

              if (!_response) {
                _context2.next = 15;
                break;
              }

              return _context2.abrupt("return", _response);

            case 15:
              throw _context2.t0;

            case 16:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[0, 8]]);
    }));

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }()));
});